== Let's start the demo

....
mkdir handlers
cd handlers
gradle init --type java-application
idea build.gradle
....

....
plugins {
    id 'io.ratpack.ratpack-java' version '1.4.5'
}


repositories {
    jcenter()
}

mainClassName = 'App'
....

....
import ratpack.server.RatpackServer;

public class App {
    public static void main(String[] args) throws Exception {
        RatpackServer.start(serverSpec -> serverSpec
                .handlers(chain -> chain
                        .get(ctx -> ctx.render("Hello Skyway"))
                )
        );
    }
}
....

This is the simplest possible ratpack app. it isn't short enough to fit in a tweet, but it would be if we used groovy!
Show running through command line - gradle run

....
gradle run -t
....

now lets look at the simplest possible implementation of a proxy in ratpack.

....
import ratpack.http.client.HttpClient;
import ratpack.server.RatpackServer;

import java.net.URI;

public class App {
    private static String HOST = "localhost";
    private static int PORT = 5151;

    public static void main(String[] args) throws Exception {
        RatpackServer.start(serverSpec -> serverSpec
                .handlers(chain -> chain
                        .all(ctx -> {
                            HttpClient httpClient = ctx.get(HttpClient.class);
                            URI oUri = new URI(ctx.getRequest().getRawUri());

                            URI proxyUri = new URI("http",
                                    oUri.getUserInfo(),
                                    HOST,
                                    PORT,
                                    oUri.getPath(),
                                    oUri.getQuery(),
                                    oUri.getFragment());

                            ctx.getRequest().getBody().flatMap(incoming -> {
                                        return httpClient.requestStream(proxyUri, requestSpec -> {
                                            requestSpec.headers(mutableHeaders -> {
                                                mutableHeaders.copy(ctx.getRequest().getHeaders());
                                            });
                                            requestSpec.method(ctx.getRequest().getMethod());
                                            requestSpec.body(b -> b.buffer(incoming.getBuffer()));
                                        });
                                    }).then(responseStream -> {
                                        responseStream.forwardTo(ctx.getResponse());
                                    });
                        })
                )
        );
    }
}
....


=== what is a chain? -
the chain is just a way to compose handlers together. the chain does no work other than delegating to the handlers
based on the request. The all method is one way to build that chain.

=== What is a handler?

Each handler is simply a function which either responds to the request, or does some work and delegates to another
handler. Our handler chain is a single function which is passed to the all method. This indicates that every request
will be processed by this handler. In the hello-world example generated by lazybones the get method was used, which
processes only HTTP GET requests for /.

=== What is the context?

Access the HTTP Request and Response
Delegation and flow control (via the next() and insert() methods)
Access to contextual objects
Convenience for common handler operations

The context is a registry, you can think of it as a way to do DI with your handlers.

=== Promise API

as shown by httpClient.requestStrem

There's a lot in this little example. You can see that it's very different from SpringBoot or Grails.
There are no controllers, no views, we're not using code generation. We'll address these topics a little more in depth
as we go, but are there questions now?
